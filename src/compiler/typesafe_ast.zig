const std = @import("std");
const root = @import("root");
const mem = std.mem;
const Allocator = mem.Allocator;
const Type = root.Type;

pub const Block = std.DoublyLinkedList(Stmt);
pub const BlockIter = struct {
    list: *const Block,
    current: ?*Block.Node,

    pub fn init(b: *const Block) BlockIter {
        return .{
            .list = b,
            .current = b.first,
        };
    }

    pub fn next(self: *BlockIter) ?*const Block.Node {
        const current = self.current;
        if (current) |c| {
            self.current = c.next;
        }
        return current;
    }
};

/// This AST is assumed to be type safe
/// since it is generated by the analyzer.
pub const Program = struct {
    // functions: []const Function,
    body: Block,

    pub fn deinit(self: Program, allocator: Allocator) void {
        for (self.body.items) |body| {
            body.deinit(allocator);
        }
        self.body.deinit();
    }
};

pub const Stmt = union(enum) {
    Expr: Expr,
    Var: struct {
        name: []const u8,
        value: ?Expr,
        tp: Type,
        global: bool = false,
    },
    Const: struct {
        name: []const u8,
        value: ?Expr,
        tp: Type,
        global: bool = false,
    },

    pub fn create(allocator: Allocator, value: Stmt) Allocator.Error!Stmt {
        const result = try allocator.create(Stmt);
        result.* = value;
        return result;
    }

    pub fn get_type(self: Stmt) Type {
        return switch (self) {
            .Expr => |expr| expr.get_type(),
            .Var => |vr| vr.tp,
            .Const => |con| con.tp,
        };
    }

    pub fn deinit(self: Stmt, allocator: Allocator) void {
        switch (self) {
            .Expr => |expr| expr.deinit(allocator),
            .Var => |vr| {
                if (vr.value) |value| {
                    value.deinit(allocator);
                }
            },
            .Const => |con| {
                if (con.value) |value| {
                    value.deinit(allocator);
                }
            },
        }
    }
};

pub const Expr = union(enum) {
    pub const AssignNode = struct {
        tp: Type,
        vr: *const Expr,
        value: *const Expr,
    };
    pub const BinaryNode = struct {
        tp: Type,
        left: *const Expr,
        right: *const Expr,
        op: []const u8,
    };
    pub const UnaryNode = struct {
        tp: Type,
        op: []const u8,
        right: *const Expr,
    };
    pub const StringNode = struct {
        tp: Type,
        v: []const u8,
    };
    pub const ConstantNode = struct {
        tp: Type,
        v: []const u8,
    };
    Binary: BinaryNode,
    Unary: UnaryNode,
    Assign: AssignNode,
    String: StringNode,
    Constant: ConstantNode,

    pub fn create(allocator: Allocator, value: Expr) Allocator.Error!*Expr {
        const result = try allocator.create(Expr);
        result.* = value;
        return result;
    }

    pub fn get_type(self: Expr) Type {
        return switch (self) {
            .Binary => |bin| bin.tp,
            .Unary => |un| un.tp,
            .Assign => |a| a.tp,
            .String => |str| str.tp,
            .Constant => |con| con.tp,
        };
    }

    pub fn set_type(self: *Expr, tp: Type) void {
        switch (self.*) {
            .Binary => |*bin| bin.tp = tp,
            .Unary => |*un| un.tp = tp,
            .Assign => |*a| a.tp = tp,
            .String => |*str| str.tp = tp,
            .Constant => |*con| con.tp = tp,
        }
    }

    pub fn is_assignment(self: Expr) bool {
        return self == .Assign;
    }

    pub fn deinit(self: Expr, allocator: Allocator) void {
        switch (self) {
            .Binary => |bin| {
                bin.left.deinit(allocator);
                bin.right.deinit(allocator);

                allocator.destroy(bin.left);
                allocator.destroy(bin.right);
            },
            .Unary => |un| {
                un.right.deinit(allocator);

                allocator.destroy(un.right);
            },
            .Assign => |a| {
                a.vr.deinit(allocator);
                a.value.deinit(allocator);

                allocator.destroy(a.vr);
                allocator.destroy(a.value);
            },
            .String => {},
            .Constant => {},
        }
    }
};

pub const Function = struct {
    name: []const u8,
    args: []const Arg,
    body: []const Stmt,
    is_local: bool,

    const Arg = struct {
        name: []const u8,
    };
};
